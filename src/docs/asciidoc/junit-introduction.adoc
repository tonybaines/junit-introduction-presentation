= JUnit Introduction
2015-07-02
:revnumber: {project-version}
ifndef::imagesdir[:imagesdir: images]
ifndef::sourcedir[:sourcedir: ../java]

== Some Definitions

=== Test Automation
[%step]
* Writing and running repeatable verifications
** of the behaviour of an individual piece of code
** ..., or an entire system
** using tools such as JUnit or Selenium

=== TDD
[%step]
* A method of incrementally designing and implementing features
in a software system
** by alternately
*** specifying expected behaviour in automated tests
*** writing production code to meet the specification
** and periodically improving the design through refactoring
*** changing the implementation without changing the behaviour


== The value of test automation

The value that a team gets from automated testing **must** be greater
than the effort that they expend creating and maintaining those tests.

[%step]
* Benefits include
** Regression testing
** Fast feedback on changes
** 'Documentation' on the behaviour of the system
* A valuable test
** Is __fast__
** Fails for one reason (specific)
** Expresses the scenario and intent of the test

== Automated Unit Testing

Fine-grained control over the unit under test, useful for covering all significant code paths

[%step]
* Solitary
** One class or method under test
* Sociable
** Any other test within the component boundary

== Automated Integration Testing

Used for checking assumptions about  other components' interfaces and how they behave

[%step]
* *Real* External Component
** e.g. Database - schema and SQL
** e.g. RESTful service - URIs and payloads

== Automated Functional Testing

e.g. Selenium, JMeter

[%step]
* End to end scenarios
* Focus on the happy-path
** Rely on more detailed tests

== Anatomy of an Automated Test

=== Arrange
[%step]
* Set-up the system / module under test
** e.g. set configuration parameters, populate DB tables

=== Act
[%step]
* Invoke some action(s) on the system / module
** e.g. login and submit a form with valid values

=== Assert
[%step]
* Verify the expected state
** e.g. at the correct page, values in the DB as expected



== Arranging

Bring the state of the system (or part of it) into a known state

* May involve
** initialising variables
** simple building of objects
** setting up stub responses of collaborators

[WARNING]
*If arranging a test swamps out its intent it might mean excessive coupling*

=== Object Mothers

A helper or parent class holds a list of pre-defined instances


[source, language="java"]
----
Certificate CERTIFICATE_1 = new Certificate() {{
    setId(1L);
    setName("testCertificate1");
    setComment("COMMENT-1001");
    setAssignedClusters(new ArrayList<String>());
}};
----

* Duplicated data objects might be constants
* Reusing these constants in different tests and contexts
** couples the tests together (making them more brittle)
** makes naming them harder
** confuses intent if reused in graphs of related objects

=== Builders

The Fluent Builder pattern can be used to make assembling objects easier.

[source, language="java"]
----
Certificate CERTIFICATE_1 = make(CERTIFICATE_MAKER
        .but(with(id, 1l),
             with(name, "testCertificate1")));
----

* E.g. the 'Make It Easy' library
** Makes it easier to create a new instance for each test
** Instances can be named for their role in the specific test

== Acting

Exercise the system/component/class

* One operation
* Express the intent with variable names if required

[source, language="java"]
----
public void whenTheTransactionIsExecuted...() {
  //...
  successfulTransaction =
    Transaction.from(source).to(destination).of(10.00);
  successfulTransaction.execute();
  //...
}
----

== Asserting
* Role
* Hamcrest

=== State-based Testing

Assertions based on _values_

1. Do something which changes the state of the system
2. Verify the new state

[source, language="java"]
----
public void shouldHaveNoBalanceWhenANewAccountIsRegistered() {
  // ...
  assertThat(bankAccount.balance(), is(Money.NaN));
}
----

=== Behaviour-based Testing

Assertions based on _interactions_

1. Send a signal
2. Verify the interactions

[source, language="java"]
----
public void
  whenTheSourceAccountHasInsufficientFundsTheDestinationIsNotCredited() {
  // ...
  verify(destinationAccount, never()).credit(anyFloat());
}
----

== Working around problems

=== The class I want to unit test creates expensive resources
* Move initialisation code to a Factory Method and override in the test
* Use Power Mock to intercept creation and replace fields

=== There's behaviour in a parent class that makes it hard to unit test
* Power Mock

=== There's a Long-running or Asynchronous operation
* Want to wait just long enough for the operation to complete
* Don't want to wait too long (slow tests) or too little (false failure)

* Tempus Fugit
* WaitFor

=== The logic I want to test is in a private method
* Encapsulate the logic e.g. helper class
* Also works for moving logic from an abstract parent class to make it testable


== Maintaining Tests

Like any other code, tests need maintenance

* If a test fails for an unrelated reason to a change
* If a test runs slow it slows down feedback
* If a test is unclear in its intent
* If there is excessive duplication
